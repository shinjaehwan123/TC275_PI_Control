/**********************************************************************************************************************
 * \file Appscheduling.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "driver_stm.h"
#include "Appscheduling.h"
#include "DrvAdc.h"
#include "Blink_LED.h"
#include "MidAdc.h"
#include <stdio.h>
#include "GtmTomPwm.h"
#include "ConfigurationIsr.h"
#define LED         &MODULE_P10,2
#define ENCA        &MODULE_P33,3
#define ENCB        &MODULE_P11,2
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
        uint32 u32nuCnt1ms;
        uint32 u32nuCnt10ms;
        uint32 u32nuCnt50ms;
        uint32 u32nuCnt100ms;
        uint32 u32nuCnt500ms;
} TestCnt;
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
static void AppTask1ms(void);
static void AppTask1ms(void);
static void AppTask10ms(void);
static void AppTask50ms(void);
static void AppTask100ms(void);
static void AppTask500ms(void);

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*****************************************************************S****************************************************/
TestCnt stTestCnt;
uint32 ULSraw;
uint32 msec;
static float32 T = 0;

static float32 Ts = 0.001;
static float32 theta, theta_old = 0;
static float32 Wd = 2.5;
static float32 w_ref, Vin, w, w_old, error_w, error_w_int, error_w_int_old = 0;
static float32 kp = 0.3, ki = 0.4;
static sint32 EncoderTicks, SteadyStateTicks = 0;
static uint32 EncoderA;
static uint32 EncoderB;
static uint32 EncoderState = 0;
static uint32 OldEncoderState = 0;
static uint32 EncoderFlag,dir = 0;
float32 DUTY[2] = {0, 0};

float32 LPF(float32 Y_fil_d, float32 U,uint32 cf,float32 Ts){
    float32 Y_fil;
    Y_fil = (1-Ts*cf)*Y_fil_d+Ts*cf*U;
    return Y_fil;
}
static void Apnotask(void){
    EncoderA = IfxPort_getPinState(ENCA);
    EncoderB = IfxPort_getPinState(ENCB);
    if((EncoderA == 0)&&(EncoderB == 0)){
        EncoderState = 0;
    }
    if((EncoderA == 1)&&(EncoderB == 0)){
        EncoderState = 1;
    }
    if((EncoderA == 1)&&(EncoderB == 1)){
        EncoderState = 2;
    }
    if((EncoderA == 0)&&(EncoderB == 1)){
        EncoderState = 3;
    }

    if(EncoderFlag == 0){
        OldEncoderState = EncoderState;
        EncoderFlag = 1;
    }

    if((EncoderState-OldEncoderState == 1 || EncoderState-OldEncoderState ==-3)){
        dir =0; //정방향 가정
    }
    if((EncoderState-OldEncoderState == -1 || EncoderState-OldEncoderState== 3)){
        dir =1; // 역방향 가정
    }

    if(OldEncoderState != EncoderState){
        switch(dir){
            case 0:
                EncoderTicks++;
                break;
            case 1:
                EncoderTicks--;
                break;
        }
    }
    if(T > 19 && T < 26){
        if(OldEncoderState != EncoderState){
            switch(dir){
                case 0:
                    SteadyStateTicks++;
                    break;
                case 1:
                    SteadyStateTicks--;
                    break;
            }
        }
    }
    OldEncoderState = EncoderState;
    //A,B Encoder 둘다 falling, rising 세기 때문에 4로 나누고 Encoder 성능이 12ppr 이기 때문에
    theta = (EncoderTicks *2 * 3.141592)/(4*12);

}

static void AppTask1ms(void){
    msec++;
    T = 0.001*msec;
    //0.001마다 갱신해줌
    w = (float32)(theta - theta_old)/Ts; //변위를 시간으로 나눠주어 속도를 나타냄(각속도)
    w = LPF(w_old, w, 160, Ts);
    w_old = w;
    //W_RPM = (uint32)(60*w/(2*3.141592));
    theta_old = theta;

    if(T<=4)
    {
        w_ref = 0;
    }
    else if(T > 4 && T < 19)
    {   //각속도를 WD까지 증가시켜줌
        w_ref = 0.06667*Wd*(2*3.141592)*(T-4);
    }
    else if(T >= 19 && T <= 26)
    {
        w_ref = Wd*(3.141592*2);
    }
    else if(T > 26 && T<41)
    {
        w_ref = Wd*(3.141592*2)-0.06667*Wd*(2*3.141592)*(T-26);
    }
    else if(T > 41)
    {
        w_ref=0;
    }
    if(T <= 4)
    {   //이때는 PID제어를 하지 않음.
        Vin = 0;
        EncoderTicks = 0;
    }
    else if(T > 4 && T < 41)
    {
        error_w = w_ref - w;
        error_w_int = error_w_int_old + (error_w)*Ts;
        error_w_int_old = error_w_int;

        if(error_w_int > 10)
        {
            error_w_int = 10;
        }

        //kp는 비례제어, ki는 적분제어 즉 pid제어를 함
        Vin = (kp*error_w+ki*error_w_int);

        if(Vin > 11)
        {
            Vin = 11;
        }
        else if(Vin < 0)
        {
            Vin = 0;
        }
    }
    else if(T > 41)
    {
        Vin = 0;
    }
    DUTY[0] = Vin/12;
    g_GtmTomPwmHl.tOn[0] = DUTY[0];
    GtmTomPwmHl_run();
}

static void AppTask10ms(void){
    //stTestCnt.u32nuCnt10ms++;

///////////////////////////////////////////////////////////////////////
//    if (T < 5) {
//        DUTY[0] = 0;
//    } else if (T >= 5 && T < 10) {
//        DUTY[0] = 0.3;
//    } else {
//        DUTY[0] = 0;
//    }
//    g_GtmTomPwmHl.tOn[0] = DUTY[0];
//    GtmTomPwmHl_run();
}

static void AppTask50ms(void){
//    stTestCnt.u32nuCnt50ms++;
//    DrvAdc_GetAdcRawGroup0();
//    SensorAdcRaw* pstSensorAdcRaw = MidAdc_GetAdcGroup0senseRaw();
//    ULSraw = pstSensorAdcRaw->UlSSense1_Raw;
    //blink_LED(ULSraw);
//    if(ULSraw<1000){
//        IfxPort_setPinHigh(LED);
//    }
//    else{
//        IfxPort_setPinLow(LED);
//    }
//    printf("%lld\n", ULSraw);
    //IfxPort_togglePin(LED);
}
static void AppTask100ms(void){
    //stTestCnt.u32nuCnt100ms++;

}
static void AppTask500ms(void){
    //stTestCnt.u32nuCnt500ms++;
    //printf("%d\n", EncoderTicks);
}
void Appscheduling(void){
    Apnotask();
    if(stSchedulingInfo.u8nuScheduling1msFlag == 1u){
        stSchedulingInfo.u8nuScheduling1msFlag = 0u;
        AppTask1ms();
        if(stSchedulingInfo.u8nuScheduling10msFlag == 1u){
            stSchedulingInfo.u8nuScheduling10msFlag = 0u;
            AppTask10ms();
        }
        if(stSchedulingInfo.u8nuScheduling50msFlag == 1u){
            stSchedulingInfo.u8nuScheduling50msFlag = 0u;
            AppTask50ms();
        }
        if(stSchedulingInfo.u8nuScheduling100msFlag == 1u){
            stSchedulingInfo.u8nuScheduling100msFlag = 0u;
            AppTask100ms();
        }
        if(stSchedulingInfo.u8nuScheduling500msFlag == 1u){
            stSchedulingInfo.u8nuScheduling500msFlag = 0u;
            AppTask500ms();
        }
    }
}
